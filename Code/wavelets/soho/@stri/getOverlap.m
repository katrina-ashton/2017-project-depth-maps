function overlap = getOverlap( st1, st2) 
% Compute the overlap (area) between two spherical triangles which have been 
% generated by the subdivision of an octahedron (or for which it can be 
% guaranteed that they only lie in one octant)
% st1  spherical triangle 1
% st2  spherical triangle 2
% overlap  size of the overlapping area

  overlap = 0;
  
  % trivial reject
  % bounding caps do not overlap so the sperical triangles cannot overlap
  if((st1.max_arc + st2.max_arc) < acos( dot( st1.c_point, st2.c_point)))
    return;
  end
  
  % check if the triangles are identical
  % note that this might provide a speedup for non-rotated domains but most
  % likely not if st2 is an element of a rotated basis
  % sort the points so that the order in which  the triangles are set up does
  % not matter
  st1_verts_sorted = sort( st1.verts_ec')';
  st2_verts_sorted = sort( st2.verts_ec')';
  
  diff_small = (st1_verts_sorted - st2_verts_sorted) < 0.01;
  if( all(diff_small))
    overlap = st1.area;
    return;
  end
  
  % each row describes which vertices form together one of the planes 
  % corressponding to the edges of the spherical triangles, for example row 1 =
  % [2 3] tells that plane1 is formed by edges 2 and 3
  plane_setup = [ 2 3; 3 1; 1 2];
  
  % test which points of the second triangle are in the first one
  % the center of the sphere and two vertices of the spherical triangle form a
  % plane in R^3. If a point lies on the same site of all possible planes (set
  % up in a consistent manner) than it is contained in the spherical triangle
  % cf. [Kautz 2004]
  
  % set up the planes in Hessian normal form (pass through the origin so there's
  % no constant term
  % For the unit sphere those center is in the origin, the vectors from the
  % center to the vertices of the spherical triangle are just the vertex
  % coordinates
  % point on an edge are considered as inside
  
  for i = 1 : 3
    n1(:,i) = cross( st1.verts_ec(:,plane_setup(i,1)), ...
                     st1.verts_ec(:,plane_setup(i,2)) );
    n1(:,i) = n1(:,i) / norm( n1(:,i));
    n2(:,i) = cross( st2.verts_ec(:,plane_setup(i,1)), ...
                     st2.verts_ec(:,plane_setup(i,2)) );
    n2(:,i) = n2(:,i) / norm( n2(:,i));
  end 
  
  % test all three vertices
  for i = 1 : 3
    % st2 in st1
    st2_in_st1(i) =    (dot( n1(:,1), st2.verts_ec(:,i)) >= -0.0000001) ...
                    && (dot( n1(:,2), st2.verts_ec(:,i)) >= -0.0000001) ...
                    && (dot( n1(:,3), st2.verts_ec(:,i)) >= -0.0000001);
    % st1 in st2
    st1_in_st2(i) =    (dot( n2(:,1), st1.verts_ec(:,i)) >= -0.0000001) ...
                    && (dot( n2(:,2), st1.verts_ec(:,i)) >= -0.0000001) ...
                    && (dot( n2(:,3), st1.verts_ec(:,i)) >= -0.0000001);
  end

  % check if all vertices of st2 are in st1 or vice versa
  % corresponds to case_3_0
  if( all( st2_in_st1))
    overlap = st2.area;
    return;    
  elseif( all( st1_in_st2))
    overlap = st1.area;
    return;
  end
  
  % choose correct handler function for configuration
  % some cases do not exist, problem is symetric
  if( (0 == sum( st2_in_st1)) && (0 == sum( st1_in_st2)))
    overlap = case_0_0( st1, st2, plane_setup);
    
  elseif( (1 == sum( st2_in_st1)) && (0 == sum( st1_in_st2)))
    overlap = case_1_0( st2, st1, st2_in_st1, st1_in_st2, plane_setup);
    
  elseif( (0 == sum( st2_in_st1)) && (1 == sum( st1_in_st2)))
    overlap = case_1_0( st1, st2, st1_in_st2, st2_in_st1, plane_setup);
    
  elseif( (2 == sum( st2_in_st1)) && (0 == sum( st1_in_st2)))
    overlap = case_2_0( st2, st1, st2_in_st1, st1_in_st2, plane_setup);    
    
  elseif( (0 == sum( st2_in_st1)) && (2 == sum( st1_in_st2)))
    overlap = case_2_0( st1, st2, st1_in_st2, st2_in_st1, plane_setup);    
    
  elseif( (1 == sum( st1_in_st2)) && (1 == sum( st2_in_st1)))
    overlap = case_1_1( st1, st2, st1_in_st2, st2_in_st1, plane_setup);
    
  elseif( (1 == sum( st2_in_st1)) && (2 == sum( st1_in_st2)))
    overlap = case_2_1( st1, st2, st1_in_st2, st2_in_st1, plane_setup);  
  
  elseif( (2 == sum( st2_in_st1)) && (1 == sum( st1_in_st2)))
    overlap = case_2_1( st2, st1, st2_in_st1, st1_in_st2, plane_setup);  
    
  elseif( (2 == sum( st2_in_st1)) && (2 == sum( st1_in_st2)))
    overlap = case_2_2( st1, st2, st1_in_st2, st2_in_st1, plane_setup);
    
  else
    error( 'Unhandeled case.');
  end
  
  if( abs( overlap) < 0.0000001)
    overlap = 0;
  end
  
  assert( overlap >= 0);
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function overlap = case_2_2( st1, st2, st1_in_st2, st2_in_st1, plane_setup)
% 

  overlap = 0;
  
  shared_verts_st1 = [];
  shared_verts_st2 = [];
  for i = 1 : 3
    for k = 1 : 3
      if( all( abs(st1.verts_ec( : , i) - st2.verts_ec( : , k)) < 0.000001) )
        shared_verts_st1( end + 1) = i;
        shared_verts_st2( end + 1) = k; 
      end
    end
  end

  num_shared_verts = numel( shared_verts_st1);
  
  % check if one vertex in common and the other lie on the edge of the other
  % spherical triangle
  if( 1 == num_shared_verts)
    
    % shared vertex has to be in the set of vertices which are inside
    in_st1_in_st2 = find( 1 == st1_in_st2);
    in_st2_in_st1 = find( 1 == st2_in_st1);  
    if(    ( ~ isMember( shared_verts_st1, in_st1_in_st2)) ...
        || ( ~ isMember( shared_verts_st2, in_st2_in_st1)))
      
      error( 'Unexpected configuration');
    end
    
    % find the indices of the non shared vertices

    all_indices = [1 2 3];
    
    non_shared_verts_st1 = setdiff( all_indices, shared_verts_st1 );
    non_shared_verts_st2 = setdiff( all_indices, shared_verts_st2 );    
    
    vs_st1 = st1.verts_ec( : , shared_verts_st1 );
    vs_st2 = st2.verts_ec( : , shared_verts_st2 );
    
    vns_st1 = st1.verts_ec( : , non_shared_verts_st1 );
    vns_st2 = st2.verts_ec( : , non_shared_verts_st2 );    
    
    % span planes for the sides of the non-shared vertices    
    p_st1 = cross( vns_st1(:,1), vns_st1(:,2));
    p_st1 = p_st1 / norm( p_st1);
    p_st2 = cross( vns_st2(:,1), vns_st2(:,2));
    p_st2 = p_st2 / norm( p_st2);                 
    
    % distance of point to plane
    dist_st2_p_st1 = dot( p_st1, vs_st2);
    dist_st1_p_st2 = dot( p_st2, vs_st1);

    if(    ( abs( dist_st2_p_st1 - 1) > 0.000001) ...
        || ( abs( dist_st1_p_st2 - 1) > 0.000001))
      error( 'Unexpected configuration');
    end
    
    % check if the points are within the arcs
    cos_arc_st1 = dot( vns_st1(:,1), vns_st1(:,2) );
    cos_arc_st2 = dot( vns_st2(:,1), vns_st2(:,2) );

    if( (dot( vs_st2, vns_st1(:,1)) < cos_arc_st1) ...
      || (dot( vs_st2, vns_st1(:,2)) < cos_arc_st1) ...
      || (dot( vs_st1, vns_st2(:,1)) < cos_arc_st2) ...
      || (dot( vs_st1, vns_st2(:,2)) < cos_arc_st2) )
      
      error( 'Unexpected configuration');
    end
    
    % find the vertices which are inside the other but not shared  
    v_st1_in_ns = st1.verts_ec( : , setdiff( in_st1_in_st2, shared_verts_st1));
    v_st2_in_ns = st2.verts_ec( : , setdiff( in_st2_in_st1, shared_verts_st2));
    
    % the triangle is the area between the 
    verts = [v_st1_in_ns  vs_st1  v_st2_in_ns];
    if( isDegenerated( verts))
      error( 'Unexpected configuration');
    else
      st_temp = stri( verts);
      overlap = st_temp.area;
    end
    
  % check if the spherical triangles are adjacent, ie. they have one edge they
  % share, if then the third vertex of the two triangles are on different
  % sides of the shared edge, than the overlap is zero (note that the great
  % arc between two points is unique (up to the long / short way))
  elseif( 2 == num_shared_verts) 

    % plane spanned by the shard vertices
    in = find( 1 == st1_in_st2);
    % plane in normal form
    p_n = cross( st1.verts_ec(:,in(1)), st1.verts_ec(:,in(2)));
    p_n = p_n / norm( p_n);

    % the third vertices lie on different sides if the dot product with the plane
    % normal has different signs.
    if(    sign(dot( st1.verts_ec( : , find( 0 == st1_in_st2)), p_n)) ...
        == sign(dot( st2.verts_ec( : , find( 0 == st2_in_st1)), p_n)) )

      % indices of the vertex of st1 which is inside st2
      index_in_st1_in_st2 = find( 1 == st1_in_st2);
      % index of the vertices of st1 which are outside st2
      index_out_st1_in_st2 = find( 0 == st1_in_st2);
  
      % indices of the vertex of st2 which is inside st1
      index_in_st2_in_st1 = find( 1 == st2_in_st1);
      % index of the vertices of st2 which is outside st1
      index_out_st2_in_st1 = find( 0 == st2_in_st1);
      
      % setup planes corresponding to  the four relevant edges
      n1 = []; n2 = []; cos_alpha_ref_n1 = []; cos_alpha_ref_n2 = [];
      for k = 1 : 2
    
        % relevant planes of st1
        n1(:,k) = cross( st1.verts_ec( : , index_out_st1_in_st2 ), ...
                         st1.verts_ec( : , index_in_st1_in_st2(k)) ); 
        n1(:,k) = n1(:,k) / norm( n1(:,k));

        % relevant planes of st2
        n2(:,k) = cross( st2.verts_ec( : , index_out_st2_in_st1 ), ...
                         st2.verts_ec( : , index_in_st2_in_st1(k))); 
        n2(:,k) = n2(:,k) / norm( n2(:,k));

        % arcs corresponding to the relevant sides of st1
       cos_alpha_ref_n1(k) = dot( st1.verts_ec( : , index_out_st1_in_st2 ), ...
                                   st1.verts_ec( : , index_in_st1_in_st2(k)) );
        % arcs corresponding to the relevant sides of st2
        cos_alpha_ref_n2(k) = dot( st2.verts_ec( : , index_out_st2_in_st1), ...
                                   st2.verts_ec( : , index_in_st2_in_st1(k)) );
      end


      % intersection points
      i_points = [];

      % find the intersection points
      for i = 1 : 2
        for k = 1 : 2

          % vectors may not be colinear (planes are identical and therefore no
          % intersection point exists)
          if( 1 == abs( dot( n1(:,i), n2(:,k))))
            continue;
          end

          % compute intersection point, the intersection is described by an 
          % straight line passing through the origin where the intersection point
          % is the intersection of the line with S^2
          i_ik = cross( n1(:,i), n2(:,k));
          % normalize i
          i_ik = i_ik / norm( i_ik);

          % flip if pointing in the wrong direction (spherical triangles cover
          % not more than one octant, therefore a vector which spans an angle with
          % more than 90 degrees with thscre central point has to be flipped 
          % (or the triangles are anyway disjoint))
          if( dot( st1.c_point, i_ik) < 0) 
            i_ik = i_ik * -1;
          end

          % test if point lies on the arcs of st1 and st2 those planes have been
          % intersected
          cos_alpha_n1_0 = dot( i_ik, st1.verts_ec( :,index_out_st1_in_st2 ));
          cos_alpha_n1_1 = dot( i_ik, st1.verts_ec( :,index_in_st1_in_st2(i)));        

          % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
          % alpha_0 and alpha_1 are both less than 90 degrees
          if(    ((cos_alpha_n1_0 - cos_alpha_ref_n1(i)) >= -0.0000001) ...
              && ((cos_alpha_n1_1 - cos_alpha_ref_n1(i)) >= -0.0000001))

            % THIS TEST SHOULD BE REDUNDANT
            % test if point lies on the arcs of st1 and st2 those planes have been
            % intersected
            cos_alpha_n2_0 = dot( i_ik, st2.verts_ec( :,index_out_st2_in_st1));
            cos_alpha_n2_1 = dot( i_ik, st2.verts_ec( :,index_in_st2_in_st1(k)));  

            % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
            % alpha_0 and alpha_1 are both less than 90 degrees
            if(    ((cos_alpha_n2_0 - cos_alpha_ref_n2(k)) >= -0.0000001) ...
                && ((cos_alpha_n2_1 - cos_alpha_ref_n2(k)) >= -0.0000001) )

              % each edge of st2 only intersects one edge of st1
              i_points( : , end+1) = i_ik;

            end
          end      

        end
      end

      % remove ghost intersection points resulting from the shared vertices
      i_points = handleEdgeVertex2( i_points, st1.verts_ec);
      
      assert( 1 == size( i_points, 2));
      
      % setup the spherical triangle those area is the overlap
      verts = [st1.verts_ec(:,shared_verts_st1(1)) , ...
               i_points , ...
               st1.verts_ec(:,shared_verts_st1(2)) ];
      if( ~ isDegenerated( verts))
        st_temp = stri( verts);
        overlap = st_temp.area;
        
        return;
      end
        
    end
  else
    error( 'Unhandeled case at (2,2).');
  end
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function overlap = case_1_1( st1, st2, st1_in_st2, st2_in_st1, plane_setup)
% One vertex of st1 is in st2 and vice versa.

  overlap = 0;
  
  % indices of the vertex of st1 which is inside st2
  index_in_st1_in_st2 = find( 1 == st1_in_st2);
  % index of the vertices of st1 which are outside st2
  index_out_st1_in_st2 = find( 0 == st1_in_st2);
  
  % indices of the vertex of st2 which is inside st1
  index_in_st2_in_st1 = find( 1 == st2_in_st1);
  % index of the vertices of st2 which is outside st1
  index_out_st2_in_st1 = find( 0 == st2_in_st1);
  
  n1 = []; n2 = []; cos_alpha_ref_n1 = []; cos_alpha_ref_n2 = [];
  for k = 1 : 2
    % relevant planes of st1
    n1(:,k) = cross( st1.verts_ec( : , index_in_st1_in_st2), ...
                     st1.verts_ec( : , index_out_st1_in_st2(k)) ); 
    n1(:,k) = n1(:,k) / norm( n1(:,k));

    % relevant planes of st2
    n2(:,k) = cross( st2.verts_ec( : , index_in_st2_in_st1), ...
                     st2.verts_ec( : , index_out_st2_in_st1(k))); 
    n2(:,k) = n2(:,k) / norm( n2(:,k));

    % arcs corresponding to the relevant sides of st1
    cos_alpha_ref_n1(k) = dot( st1.verts_ec( : , index_in_st1_in_st2), ...
                               st1.verts_ec( : , index_out_st1_in_st2(k)) );
    % arcs corresponding to the relevant sides of st2
    cos_alpha_ref_n2(k) = dot( st2.verts_ec( : , index_in_st2_in_st1), ...
                               st2.verts_ec( : , index_out_st2_in_st1(k)) );
  end
    
  % intersection points
  i_points = [];
  % intersected edges of st1
  i_edges_st1 = [];

  % find the intersection points
  for i = 1 : 2
    for k = 1 : 2
  
      % vectors may not be colinear (planes are identical and therefore no
      % intersection point exists)
      if( 1 == abs( dot( n1(:,i), n2(:,k))))
        continue;
      end
        
      % compute intersection point, the intersection is described by an 
      % straight line passing through the origin where the intersection point
      % is the intersection of the line with S^2
      i_ik = cross( n1(:,i), n2(:,k));
      % normalize i
      i_ik = i_ik / norm( i_ik);
        
      % flip if pointing in the wrong direction (spherical triangles cover
      % not more than one octant, therefore a vector which spans an angle with
      % more than 90 degrees with the central point has to be flipped 
      % (or the triangles are anyway disjoint))
      if( dot( st1.c_point, i_ik) < 0) 
        i_ik = i_ik * -1;
      end
    
      % test if point lies on the arcs of st1 and st2 those planes have been
      % intersected
      cos_alpha_n1_0 = dot( i_ik, st1.verts_ec( :,index_in_st1_in_st2));
      cos_alpha_n1_1 = dot( i_ik, st1.verts_ec( :,index_out_st1_in_st2(i)));        
        
      % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
      % alpha_0 and alpha_1 are both less than 90 degrees
      if(    ((cos_alpha_n1_0 - cos_alpha_ref_n1(i)) >= -0.0000001) ...
          && ((cos_alpha_n1_1 - cos_alpha_ref_n1(i)) >= -0.0000001))

        % THIS TEST SHOULD BE REDUNDANT
        % test if point lies on the arcs of st1 and st2 those planes have been
        % intersected
        cos_alpha_n2_0 = dot( i_ik, st2.verts_ec( :,index_in_st2_in_st1));
        cos_alpha_n2_1 = dot( i_ik, st2.verts_ec( :,index_out_st2_in_st1(k)));  
          
        % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
        % alpha_0 and alpha_1 are both less than 90 degrees
        if(    ((cos_alpha_n2_0 - cos_alpha_ref_n2(k)) >= -0.0000001) ...
            && ((cos_alpha_n2_1 - cos_alpha_ref_n2(k)) >= -0.0000001) )
        
          % each edge of st2 only intersects one edge of st1
          i_points( : , end+1) = i_ik;
          i_edges_st1( end+1) = i;
            
        end
      end      
      
    end
  end
  
  assert( size( i_points, 2) >= 2);
  if( size( i_points, 2) > 2)
    if( 0 == getNumberDuplicateVerts( i_points))
      
      i_points = handleEdgeVertex2( i_points, ...
                                    st1.verts_ec(:,index_in_st1_in_st2));
      if( size( i_points, 2) ~= 2)                        
        i_points = handleEdgeVertex2( i_points, ...
                                    st2.verts_ec(:,index_in_st2_in_st1));
        if( size( i_points, 2) ~= 2)
          error('Unexpected configuration.');
        end
      end      
    end
  end

  % compute the spherical triangle those union is the overlap
  
  for i = 1 : 2
    
    verts = [st1.verts_ec( : , index_in_st1_in_st2) ...
             i_points( : , 1) ...
             st2.verts_ec( : , index_in_st2_in_st1)];
  
    if( ~ isDegenerated( verts))
      st_temp = stri( verts);
      overlap = overlap + st_temp.area;
    end
    
  end
  
end

  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function overlap = case_2_1( st1, st2, st1_in_st2, st2_in_st1, plane_setup)
% Two vertices of st1 lie in st2 but only one vertex of st2 in st1
  
  overlap = 0;
  
  % indices of the vertices of st1 which are inside st2
  index_in_st1_in_st2 = find( 1 == st1_in_st2);
  % index of the vertex of st1 which is outside st2
  index_out_st1_in_st2 = find( 0 == st1_in_st2);
  
  % indices of the vertex of st2 which is inside st1
  index_in_st2_in_st1 = find( 1 == st2_in_st1);
  % index of the vertices of st2 which is outside st1
  index_out_st2_in_st1 = find( 0 == st2_in_st1);

  n1 = []; n2 = []; cos_alpha_ref_n1 = []; cos_alpha_ref_n2 = [];
  for k = 1 : 2
    % relevant planes of st1
    n1(:,k) = cross( st1.verts_ec( : , index_out_st1_in_st2), ...
                     st1.verts_ec( : , index_in_st1_in_st2(k)) ); 
    n1(:,k) = n1(:,k) / norm( n1(:,k));

    % relevant planes of st2
    n2(:,k) = cross( st2.verts_ec( : , index_in_st2_in_st1), ...
                     st2.verts_ec( : , index_out_st2_in_st1(k))); 
    n2(:,k) = n2(:,k) / norm( n2(:,k));

    % arcs corresponding to the relevant sides of st1
    cos_alpha_ref_n1(k) = dot( st1.verts_ec( : , index_out_st1_in_st2), ...
                               st1.verts_ec( : , index_in_st1_in_st2(k)) );
    % arcs corresponding to the relevant sides of st2
    cos_alpha_ref_n2(k) = dot( st2.verts_ec( : , index_in_st2_in_st1), ...
                               st2.verts_ec( : , index_out_st2_in_st1(k)) );
    
  end
  
  % intersection points
  i_points = [];
  % index of edges 
  i_edges_st1 = [];

  % find the intersection points
  for i = 1 : 2
    for k = 1 : 2

      % vectors may not be colinear (planes are identical and therefore no
      % intersection point exists)
      if( 1 == abs( dot( n1(:,i), n2(:,k))))
        continue;
      end
        
      % compute intersection point, the intersection is described by an 
      % straight line passing through the origin where the intersection point
      % is the intersection of the line with S^2
      i_ik = cross( n1(:,i), n2(:,k));
      % normalize i
      i_ik = i_ik / norm( i_ik);
        
      % flip if pointing in the wrong direction (spherical triangles cover
      % not more than one octant, therefore a vector which spans an angle with
      % more than 90 degrees with the central point has to be flipped 
      % (or the triangles are anyway disjoint))
      if( dot( st1.c_point, i_ik) < 0) 
        i_ik = i_ik * -1;
      end
    
      % test if point lies on the arcs of st1 and st2 those planes have been
      % intersected
      cos_alpha_n1_0 = dot( i_ik, st1.verts_ec( :,index_out_st1_in_st2));
      cos_alpha_n1_1 = dot( i_ik, st1.verts_ec( :,index_in_st1_in_st2(i)));        
        
      % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
      % alpha_0 and alpha_1 are both less than 90 degrees
      if(    ((cos_alpha_n1_0 - cos_alpha_ref_n1(i)) >= -0.0000001) ...
          && ((cos_alpha_n1_1 - cos_alpha_ref_n1(i)) >= -0.0000001 ))

        % THIS TEST SHOULD BE REDUNDANT
        % test if point lies on the arcs of st1 and st2 those planes have been
        % intersected
        cos_alpha_n2_0 = dot( i_ik, st2.verts_ec( :, index_in_st2_in_st1));
        cos_alpha_n2_1 = dot( i_ik, st2.verts_ec( :, index_out_st2_in_st1(k)));  
          
        % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
        % alpha_0 and alpha_1 are both less than 90 degrees
        if(    ((cos_alpha_n2_0 - cos_alpha_ref_n2(k)) >= -0.0000001) ...
            && ((cos_alpha_n2_1 - cos_alpha_ref_n2(k)) >= -0.0000001))
        
          % each edge of st2 only intersects one edge of st1
          i_points( : , end+1) = i_ik;
          i_edges_st1( end+1) = i;
            
        end
      end
      
    end
  end
  
  % remove ghost points from shadows on the edge
  i_points = handleEdgeVertex2( i_points, st1.verts_ec);
  
  
  % assert( 2 <= size( i_points, 2));
  if( size( i_points, 2) > 2)   
    
    assert( size( i_points, 2) <= 3); 
    
    % one vertex has to be shared in this case
    if( 1 ~= getNumberDuplicateVerts( i_points))
      error( 'Unexpected configuration');
    end
    
    % the duplicate vertex may not be at the beginning
    if( all( abs(i_points(:,1) - i_points(:,2)) < 0.000001))
      i_points(:,2) = i_points(:,3);
    end
  end
  
  % degenerated case where the two vertices of st1 or on an edge of st2
  if( 0 == size( i_points, 2))
    
    overlap = 0;
    
  elseif( 1 == size( i_points, 2))
    
    verts = [ st1.verts_ec( :, index_in_st1_in_st2(1)) ...
              i_points ...
              st1.verts_ec( :, index_in_st1_in_st2(2)) ];
    if( ~ isDegenerated( verts))
      
      st_temp = stri( verts);
      overlap = st_temp.area;      
    end    
    
  elseif( 2 == size( i_points, 2))
  
  
    % assemble two triangles which are simple to compute and their union is the 
    % is the area of st1 which does not overlap st2

    area_diff = 0;

    verts = [st2.verts_ec( : , index_in_st2_in_st1) ...
             st1.verts_ec( : , index_out_st1_in_st2) ...
             i_points( : , 1)];

    if( ~ isDegenerated( verts)) 
      st_temp = stri( verts);
      area_diff = area_diff + st_temp.area;
    end

    verts = [st2.verts_ec( : , index_in_st2_in_st1) ...
             i_points( : , 2) ...
             st1.verts_ec( : , index_out_st1_in_st2)];

    if( ~ isDegenerated( verts)) 
      st_temp = stri( verts);
      area_diff = area_diff + st_temp.area;
    end

    overlap = st1.area - area_diff;

  else
    error( 'Unkown configuration.');
  end
    
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function overlap = case_2_0( st1, st2, st1_in_st2, st2_in_st1, plane_setup)
  
  overlap = 0;
  
  % indices of the vertices of st1 which are inside st2
  index_in = find( 1 == st1_in_st2);
  % index of the vertex of st1 which is outside st2
  index_out = find( 0 == st1_in_st2);
      
  for i = 1 : 3
    
    % compute planes corresponding to the edges of st2
    n2(:,i) = cross( st2.verts_ec(:,plane_setup(i,1)), ...
                     st2.verts_ec(:,plane_setup(i,2)) );
    n2(:,i) = n2(:,i) / norm( n2(:,i));
  end
  
  
  % set up two planes of the sides of st2 which intersect st1
  % precompute cos_angle of the arcs which correspond to the edges of st2
  n1 = [];
  cos_alpha_ref = [];

  for k = 1 : 2
    % planes
    n1(:,k) = cross( st1.verts_ec(:,index_out), st1.verts_ec(:,index_in(k))); 
    n1(:,k) = n1(:,k) / norm( n1(:,k));

    % precompute arc corresponding to the computed sides of st1 which intersect
    % one of the sides of st2
    cos_alpha_ref(k) = dot( st1.verts_ec( : , index_out), ...
                            st1.verts_ec( : , index_in(k)));
  end
    
  % intersection points
  i_points = [];
  % edge(s) of st2 corresponding to the intersection
  i_edges_st2 = [];
        
  % compute intersection of planes with those of st1        
  for i = 1 : 3
    for k = 1 : 2
        
      % vectors may not be colinear (planes are identical and therefore no
      % intersection point exists)
      if( 1 == abs( dot( n1(:,k), n2(:,i))))
        continue;
      end
        
      % compute intersection point, the intersection is described by an 
      % straight line passing through the origin where the intersection point
      % is the intersection of the line with S^2
      i_ik = cross( n1(:,k), n2(:,i));
      % normalize i
      i_ik = i_ik / norm( i_ik);
        
      % flip if pointing in the wrong direction (spherical triangles cover
      % not more than one octant, therefore a vector which spans an angle with
      % more than 90 degrees with the central point has to be flipped 
      % (or the triangles are anyway disjoint))
      if( dot( st1.c_point, i_ik) < 0) 
        i_ik = i_ik * -1;
      end
    
      % test if point lies on the arcs of st1 and st2 those planes have been
      % intersected
      cos_alpha_0 = dot( i_ik, st1.verts_ec( :,index_out));
      cos_alpha_1 = dot( i_ik, st1.verts_ec( :,index_in(k)));        
        
      % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
      % alpha_0 and alpha_1 are both less than 90 degrees
      if(    ((cos_alpha_0 - cos_alpha_ref(k) >= -0.0000001)) ...
          && ((cos_alpha_1 - cos_alpha_ref(k)) >= -0.0000001) )

        % each edge of st2 only intersects one edge of st1
        i_points( : , end+1) = i_ik;
        i_edges_st2( end+1) = i;

      end
        
    end
  end

  assert( size( i_points, 2) >= 2);
  if( size( i_points, 2) > 2)
    assert( size( i_points, 2) <= 3);
    % one vertex has to be double
    if( ~ isDegenerated( i_points))
      
      % handle additional ghost intersection point when one of the inner point
      % in fact lies on an edge
      i_points = handleEdgeVertex2( i_points, st1.verts_ec( : , index_in));      
      if( 2 ~= size( i_points, 2))
        error( 'Unexpected configuration.');
      end
    end    
  else
    assert( i_edges_st2(1) == i_edges_st2(2));
  end
  
    
  verts = [i_points(:,1) st1.verts_ec(:,index_out) i_points(:,2)];
  if( ~ isDegenerated( verts))
  
    % setup spherical triangle which is the part of st2 which does NOT overlap
    % st1
    st2_inv_diff= stri( verts);
    
    overlap = st1.area - st2_inv_diff.area;
  end
     
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
function overlap = case_1_0( st1, st2, st1_in_st2, st2_in_st1, plane_setup)  
% One vertex of st1 lies in st2 but no vertex of st2 lies in st1

  overlap = 0;

  for i = 1 : 3
    
    n1(:,i) = cross( st1.verts_ec(:,plane_setup(i,1)), ...
                     st1.verts_ec(:,plane_setup(i,2)) );
    n1(:,i) = n1(:,i) / norm( n1(:,i));
    
    % compute planes corresponding to the edges of st2
    n2(:,i) = cross( st2.verts_ec(:,plane_setup(i,1)), ...
                     st2.verts_ec(:,plane_setup(i,2)) );
    n2(:,i) = n2(:,i) / norm( n2(:,i));

    % precompute cos_angles of arcs corrseponding to the edges of the spherical
    % triangles

    cos_alpha_n1_ref(i) = dot( st1.verts_ec( : ,plane_setup(i,1)), ...
                               st1.verts_ec( : ,plane_setup(i,2)) );

    cos_alpha_n2_ref(i) = dot( st2.verts_ec( : ,plane_setup(i,1)), ...
                               st2.verts_ec( : ,plane_setup(i,2)));
  end

  
  % intersection points
  i_points = [];
  % edges of st1 corresponding to the intersection
  i_edges_st1 = [];
  % edges of st2 corresponding to the intersection
  i_edges_st2 = [];

  % find the intersection points between the edges of the spherical triangles
  for i = 1 : 3
    for k = 1 : 3

      if( 1 == abs( dot( n1(:,k), n2(:,i))))
        continue;
      end

      i_ik = cross( n2( : , i), n1( : , k));
      i_ik = i_ik / norm( i_ik);      

      % flip if pointing in the wrong direction (spherical triangles cover
      % not more than one octant, therefore a vector which spans an angle with
      % more than 90 degrees with the central point has to be flipped 
      % (or the triangles are anyway disjoint))
      if( dot( st1.c_point, i_ik) < 0) 
        i_ik = i_ik * -1;
      end

      % test if point lies on the arcs of st1 and st2 those planes have been
      % intersected
      cos_alpha_n1_1 = dot( i_ik, st1.verts_ec( : ,plane_setup(k,1)));
      cos_alpha_n1_2 = dot( i_ik, st1.verts_ec( : ,plane_setup(k,2)));        

      % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
      % alpha_0 and alpha_1 are both less than 90 degrees, cos_alpha_i is also
      % always greater than 0
      if(    ((cos_alpha_n1_1 - cos_alpha_n1_ref(k)) >= -0.0000001) ...
          && ((cos_alpha_n1_2 - cos_alpha_n1_ref(k)) >= -0.0000001) )

        cos_alpha_n2_1 = dot( i_ik, st2.verts_ec( : ,plane_setup(i,1)));
        cos_alpha_n2_2 = dot( i_ik, st2.verts_ec( : ,plane_setup(i,2)));          

        % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
        % alpha_0 and alpha_1 are both less than 90 degrees
        if(    ((cos_alpha_n2_1 - cos_alpha_n2_ref(i)) >= -0.0000001) ...
            && ((cos_alpha_n2_2 - cos_alpha_n2_ref(i)) >= -0.0000001) )

          % each edge of st2 only intersects one edge of st1
          i_points( : , end+1) = i_ik;
          i_edges_st1( end+1) = k;
          i_edges_st2( end+1) = i;            

        end

      end
    end
  end
  
  i_num = size( i_points, 2);  

  if( i_edges_st2( 1) == i_edges_st2( 2))
  
    verts = [ i_points(:,1), ...
              st1.verts_ec( : , find( 1 == st1_in_st2)), ...
              i_points(:,2) ] ;
    if( ~ isDegenerated( verts))
      st_temp = stri( verts);
      overlap = st_temp.area;
    end
    
  else
  
    % index of the vertex of st2 which is outside st1
    index_out = find( 0 == st1_in_st2);  

    area_diff = 0;

    svert = vertexBetween( i_edges_st1(1), i_edges_st1(2), plane_setup);
    verts = [i_points(:,1) svert  i_points(:,2)];
    if( ~ isDegenerated( verts))
      st_temp = stri( verts);
      area_diff = area_diff + st_temp.area;
    end

    svert = vertexBetween( i_edges_st1(3), i_edges_st1(4), plane_setup);
    verts = [i_points(:,3) svert  i_points(:,4)];
    if( ~ isDegenerated( verts))
      st_temp = stri( verts);
      area_diff = area_diff + st_temp.area;
    end

    overlap = st1.area - area_diff;
  end

end
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
function overlap = case_0_0( st1, st2, plane_setup)  
% No vertices from st1 lie in st2 and vice versa. The spherical triangles are
% either disjoint or st2 is roughly a rotated version of st1 with roughly the 
% same center of mass
% for the latter case, each edge of st2 has to intersect two edges of st1

  overlap = 0;

  for i = 1 : 3
    
    n1(:,i) = cross( st1.verts_ec(:,plane_setup(i,1)), ...
                     st1.verts_ec(:,plane_setup(i,2)) );
    n1(:,i) = n1(:,i) / norm( n1(:,i));
    
    % compute planes corresponding to the edges of st2
    n2(:,i) = cross( st2.verts_ec(:,plane_setup(i,1)), ...
                     st2.verts_ec(:,plane_setup(i,2)) );
    n2(:,i) = n2(:,i) / norm( n2(:,i));

    % precompute cos_angles of arcs corrseponding to the edges of the spherical
    % triangles

    cos_alpha_n1_ref(i) = dot( st1.verts_ec( : ,plane_setup(i,1)), ...
                               st1.verts_ec( : ,plane_setup(i,2)) );

    cos_alpha_n2_ref(i) = dot( st2.verts_ec( : ,plane_setup(i,1)), ...
                               st2.verts_ec( : ,plane_setup(i,2)));
  end

  % intersection points
  i_points = [];
  % edges of st1 corresponding to the intersection
  i_edges_st1 = [];
  % edges of st2 corresponding to the intersection
  i_edges_st2 = [];

  % find the intersection points between the edges of the spherical triangles
  for i = 1 : 3
    for k = 1 : 3

      if( 1 == abs( dot( n1(:,k), n2(:,i))))
        continue;
      end

      i_ik = cross( n2( : , i), n1( : , k));
      i_ik = i_ik / norm( i_ik);      

      % flip if pointing in the wrong direction (spherical triangles cover
      % not more than one octant, therefore a vector which spans an angle with
      % more than 90 degrees with the central point has to be flipped 
      % (or the triangles are anyway disjoint))
      if( dot( st1.c_point, i_ik) < 0) 
        i_ik = i_ik * -1;
      end

      % test if point lies on the arcs of st1 and st2 those planes have been
      % intersected
      cos_alpha_n1_1 = dot( i_ik, st1.verts_ec( : ,plane_setup(k,1)));
      cos_alpha_n1_2 = dot( i_ik, st1.verts_ec( : ,plane_setup(k,2)));        

      % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
      % alpha_0 and alpha_1 are both less than 90 degrees, cos_alpha_i is also
      % always greater than 0
      if(    ((cos_alpha_n1_1 - cos_alpha_n1_ref(k)) >= -0.0000001) ...
          && ((cos_alpha_n1_2 - cos_alpha_n1_ref(k)) >= -0.0000001) )

        cos_alpha_n2_1 = dot( i_ik, st2.verts_ec( : ,plane_setup(i,1)));
        cos_alpha_n2_2 = dot( i_ik, st2.verts_ec( : ,plane_setup(i,2)));          

        % note that cos_alpha_0 > cos_alpha1 that the angle is smaller because
        % alpha_0 and alpha_1 are both less than 90 degrees
        if(    ((cos_alpha_n2_1 - cos_alpha_n2_ref(i)) >= -0.0000001) ...
            && ((cos_alpha_n2_2 - cos_alpha_n2_ref(i)) >= -0.0000001) )

          % each edge of st2 only intersects one edge of st1
          i_points( : , end+1) = i_ik;
          i_edges_st1( end+1) = k;
          i_edges_st2( end+1) = i;            

        end

      end
    end
  end

  i_num = size(i_points,2);
  assert( numel(i_edges_st1) == i_num);

  assert( i_num <= 6);

  if( ~ (( i_num == 0) || ( i_num == 6)))
    
    % triangles overlap with just one edge
    if((numel( unique(i_edges_st1)) == 2) && (numel( unique(i_edges_st2)) == 2))
      
      % find those intersections with the edges of st1 which lie on the same one
      i_edges_st1_unique = unique(i_edges_st1);
      i_1 = find( i_edges_st1_unique(1) == i_edges_st1);  
      i_2 = find( i_edges_st1_unique(2) == i_edges_st1);        
      
      % find the one vertex of st1 which the terminating one of the part of st2
      % which overlaps st1
      % don't use unique because the algorithm used is not unique
      unique_edges_st2 = i_edges_st2(1);
      if( unique_edges_st2 == i_edges_st2(2))
        unique_edges_st2(end+1) = i_edges_st2(3);
      else
        unique_edges_st2(end+1) = i_edges_st2(2);
      end
      
      v_st2_between = vertexBetween( unique_edges_st2(1), ...
                                     unique_edges_st2(2), ...
                                     plane_setup);
      
      % setup  the two triangles those difference is the area seeked
      verts = [ i_points( :, i_1(1)) ...
                st2.verts_ec( : , v_st2_between ) ...
                i_points( :, i_1(2)) ];
      if( ~ isDegenerated( verts))
        st_temp = stri( verts);
        overlap = st_temp.area;
      end
      
      verts = [ i_points( :, i_2(1)) ...
                st2.verts_ec( : , v_st2_between ) ...
                i_points( :, i_2(2)) ];
      if( ~ isDegenerated( verts))
        st_temp = stri( verts);
        overlap = overlap - st_temp.area;
      end
      
      overlap = abs( overlap);
      
      return;
      
    end
    
    error('Unexpeceted number of intersections.');
  end
  % test if triangles are disjoint
  if( 0 == i_num) 
    return
  end


  % six intersections

  % st2 and st1 are rotated versions of each other
  % find the corners of st1 which are not covered by st2
  
  area_diff = 0;

  svert = vertexBetween( i_edges_st1( 1), i_edges_st1( 2), plane_setup);
  verts =  [i_points(:,1) st1.verts_ec(:,svert) i_points(:,2)];
  if( ~ isDegenerated( verts ))
    st_diff = stri( verts);
    area_diff = area_diff + st_diff.area;
  end

  svert = vertexBetween( i_edges_st1( 3), i_edges_st1( 4), plane_setup);
  verts = [i_points(:,3) st1.verts_ec(:,svert) i_points(:,4)];
  if( ~ isDegenerated( verts ))
    st_diff = stri( verts);
    area_diff = area_diff + st_diff.area;
  end

  svert = vertexBetween( i_edges_st1( 5), i_edges_st1( 6), plane_setup);
  verts = [i_points(:,5) st1.verts_ec(:,svert) i_points(:,6)];
  if( ~ isDegenerated( verts ))
    st_diff = stri( verts);
    area_diff = area_diff + st_diff.area;
  end

  overlap = st1.area - area_diff;

end % case_0_0
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function vertex_id = vertexBetween( edge1, edge2, plane_setup )

  % find vertex between to edges
  for i = 1 : 3
    
    if(    (plane_setup(i,1) == edge1) && ( plane_setup(i,2) == edge2) ...
        || (plane_setup(i,1) == edge2) && ( plane_setup(i,2) == edge1))
      
      vertex_id = setdiff( [1 2 3], plane_setup(i,:));
      
      return;
    end    
  end
  
  % should never get here
  error( 'Unexpected point in code.');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function bool = isDegenerated( verts)
% Test if the spherical triangle described by the rows of verts (each row forms
% one vertex) is degenerated

  bool = 0;

  if(    all( abs(verts(:,1)' - verts(:,2)') < 0.00001) ...
      || all( abs(verts(:,1)' - verts(:,3)') < 0.00001) ...
      || all( abs(verts(:,2)' - verts(:,3)') < 0.00001) )
    
    bool = 1;
  end

  if( abs(dot( verts(:,2) - verts(:,1), verts(:,3) - verts(:,1))) <= 0.00001)
    bool = 1;
  end
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function verts_multiple = getNumberDuplicateVerts( verts)
% Check if a vertex occurs multiple times in verts 

  % vertices have to occur multiple times in this case
  verts_multiple = 0;
  for i = 1 : size( verts, 2)
    for k = i + 1 : size( verts, 2)
      if( abs( verts(:,i) - verts(:,k)) < 0.000001)
        verts_multiple = verts_multiple + 1;
      end
    end
  end
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function i_points = handleEdgeVertex2( i_points, verts_in)
% there's the possibility that one vertex is one an edge and therefore
% generates an additional intersection point
% find this point and remove it
% the generated intersection point is identical to one vertex of verts_in

  % index of the vertex on the edge
  vertex_edge = [];
  
  for m = 1 : size( verts_in, 2)
    for n = 1 : size( i_points, 2)

      if( all( abs( verts_in(:,m) - i_points(:,n)) < 0.0000001))
        vertex_edge(end+1) = n;
      end          
    end
  end
      
  % remove the vertex on the edge
  temp = setdiff( [1 : size( i_points, 2)], vertex_edge);
  i_points = i_points( : , temp);
  
end